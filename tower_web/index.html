<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `tower_web` crate."><meta name="keywords" content="rust, rustlang, rust-lang, tower_web"><title>tower_web - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../dark.css"><link rel="stylesheet" type="text/css" href="../light.css" id="themeStyle"><script src="../storage.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="shortcut icon" href="../favicon.ico"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../tower_web/index.html'><img src='../rust-logo.png' alt='logo' width='100'></a><p class='location'>Crate tower_web</p><div class="sidebar-elems"><a id='all-types' href='all.html'><p>See all tower_web's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li></ul></div><p class='location'></p><script>window.sidebarCurrent = {name: 'tower_web', ty: 'mod', relpath: '../'};</script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../theme.js"></script><nav class="sub"><form class="search-form js-only"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><a id="settings-menu" href="../settings.html"><img src="../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class='fqn'><span class='out-of-band'><span id='render-detail'><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class='inner'>&#x2212;</span>]</a></span><a class='srclink' href='../src/tower_web/lib.rs.html#1-657' title='goto source code'>[src]</a></span><span class='in-band'>Crate <a class="mod" href=''>tower_web</a></span></h1><div class='docblock'><p>Tower Web is a fast web framework that aims to remove boilerplate.</p>
<p>The goal is to decouple all HTTP concepts from the application logic. You
implement your application using &quot;plain old Rust types&quot; and Tower Web uses a
macro to generate the necessary glue to serve the application as an HTTP
service.</p>
<p>The bulk of Tower Web lies in the <a href="macro.impl_web.html"><code>impl_web</code></a> macro. Tower web also
provides <a href="#deriveextract"><code>#[derive(Extract)]</code></a> (for extracting data out of the HTTP request)
and <a href="#deriveresponse"><code>#[derive(Response)]</code></a> (for converting a struct to an HTTP response).</p>
<p>The examples directory contains a number of examples showing how to use Tower
Web.</p>
<h2 id="impl_web" class="section-header"><a href="#impl_web"><code>impl_web!</code></a></h2>
<p>The <code>impl_web!</code> macro wraps one or more <code>impl</code> blocks and generates
<code>Resource</code> implementations. These structs may then be passed to
<a href="struct.ServiceBuilder.html"><code>ServiceBuilder</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p><code>impl_web!</code> looks for methods that have a <a href="#routing">routing</a> attribute. These methods
will be exposed from the web service. All other methods will be ignored.</p>
<h3 id="routing" class="section-header"><a href="#routing">Routing</a></h3>
<p>Routing attributes start with an HTTP verb and contain a path that is
matched. For example:</p>
<ul>
<li><code>#[get(&quot;/&quot;)]</code></li>
<li><code>#[post(&quot;/foo&quot;)]</code></li>
<li><code>#[put(&quot;/zomg/hello/world&quot;)]</code></li>
</ul>
<h4 id="captures" class="section-header"><a href="#captures">Captures</a></h4>
<p>Path segments that begin with <code>:</code> are captures. They match any path segment
and allow the resource method to get access to the value. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/hello/:msg&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">msg</span>: <span class="ident">String</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="prelude-val">Ok</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;Got: {}&quot;</span>, <span class="ident">msg</span>))
        }
    }
}</pre></div>
<p>The function argument is named <code>msg</code>. The macro will match the argument name
with the capture name and call <code>index</code>, passing the value captured from the
path as the first argument.</p>
<h3 id="method-arguments" class="section-header"><a href="#method-arguments">Method Arguments</a></h3>
<p><code>impl_web!</code> populates resource method arguments using data from the HTTP
request. The name of the argument is important as it tells the macro what
part of the request to use. The rules are as follows:</p>
<ul>
<li>Path captures: when the argument name matches a capture name.</li>
<li>Query string: when the argument is named <code>query_string</code>.</li>
<li>Request body: when the argument is named <code>body</code>.</li>
<li>All other names are pulled from HTTP headers.</li>
</ul>
<p>The <strong>type</strong> of all method arguments must implement <a href="extract/trait.Extract.html"><code>Extract</code></a>. So, for a
list of possible argument types, see what implements <a href="extract/trait.Extract.html"><code>Extract</code></a>.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/path/:capture&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">capture</span>: <span class="ident">String</span>, <span class="ident">query_string</span>: <span class="ident">String</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="prelude-val">Ok</span>(<span class="macro">format</span><span class="macro">!</span>(<span class="string">&quot;capture={}; query_string={}&quot;</span>, <span class="ident">capture</span>, <span class="ident">query_string</span>))
        }

        <span class="attribute">#[<span class="ident">post</span>(<span class="string">&quot;/upload&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">upload</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">content_type</span>: <span class="ident">String</span>, <span class="ident">body</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<h4 id="validation" class="section-header"><a href="#validation">Validation</a></h4>
<p>The HTTP request can be validated by specifying an argument type that
enforces an invariant. For example, if a path segment must be numeric, the
argument should be specified as such:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/users/:id&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">get_user</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">id</span>: <span class="ident">u32</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>In the previous example, requests to <code>/users/123</code> will succeed but a request
to <code>/users/foo</code> will result in a response with a status code of 400 (bad
request).</p>
<p><code>Option</code> is another useful type for validating the request. If an argument
is of type <code>Option</code>, the request will not be rejected if the argument is not
present. For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">get</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">x_required</span>: <span class="ident">String</span>, <span class="ident">x_optional</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">String</span><span class="op">&gt;</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>In the previous example, requests to <code>/</code> <strong>must</strong> provide a <code>X-Required</code>
heeader, but may (or may not) provide a <code>X-Optional</code> header.</p>
<h3 id="return-type" class="section-header"><a href="#return-type">Return type</a></h3>
<p>Resource methods return types are futures yielding items that implement
<a href="response/trait.Response.html"><code>Response</code></a>. This includes types like:</p>
<ul>
<li><a href="https://doc.rust-lang.org/std/string/struct.String.html"><code>String</code></a></li>
<li><a href="https://docs.rs/serde_json/1/serde_json/enum.Value.html"><code>serde_json::Value</code></a></li>
<li><a href="https://docs.rs/http/0.1.9/http/response/index.html"><code>http::Response</code></a></li>
</ul>
<p>The return type is either specified explicitly or <code>impl Future</code> can be used:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/foo&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">foo</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="ident">MyResponseFuture</span> {
            <span class="comment">// implementation</span>
        }

        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/bar&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">bar</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="kw">impl</span> <span class="ident">Future</span><span class="op">&lt;</span><span class="ident">Item</span> <span class="op">=</span> <span class="ident">String</span><span class="op">&gt;</span> <span class="op">+</span> <span class="ident">Send</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>Note that <code>impl Future</code> is bound by <code>Send</code>. Hyper currently requires <code>Send</code>
on all types. So, in order for our service to run with Hyper, we also need
to ensure that everything is bound by <code>Send</code>.</p>
<p>See the examples directory for more examples on responding to requests.</p>
<h3 id="limitations" class="section-header"><a href="#limitations">Limitations</a></h3>
<p>In order to work on stable Rust, <code>impl_web!</code> is implemented using
<a href="#"><code>proc-macro-hack</code></a>, which comes with some <a href="#">limitations</a>. The main one being
that it can be used only once per scope. This doesn't cause problems in
practice multiple resource implementations can be included in a single
<code>impl_web!</code> clause:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">Resource1</span> {
        <span class="comment">// impl...</span>
    }

    <span class="kw">impl</span> <span class="ident">Resource2</span> {
        <span class="comment">// impl...</span>
    }

    <span class="comment">// additional impls</span>
}</pre></div>
<h2 id="deriveextract" class="section-header"><a href="#deriveextract"><code>derive(Extract)</code></a></h2>
<p>Using <code>derive(Extract)</code> on a struct generates an <code>Extract</code> implementation,
which enables the struct to be used as an resource method argument.</p>
<p><code>derive(Extract)</code> calls <a href="http://serde.rs/">Serde</a>'s <code>derive(Deserialize)</code> internally, so all
the various Serde annotations apply here as well. See Serde's documentation
for more details on those.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Extract</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyData</span> {
    <span class="ident">foo</span>: <span class="ident">String</span>,
    <span class="ident">bar</span>: <span class="ident">u32</span>,
    <span class="ident">baz</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
}

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">query_string</span>: <span class="ident">MyData</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>In the previous example, the query string will be deserialized into the
<code>MyQueryString</code> struct and passed to the resource method. Both <code>foo</code> and
<code>bar</code> are required, but <code>baz</code> is not. This means that the following query
strings are acceptable:</p>
<ul>
<li><code>?foo=one&amp;bar=2</code></li>
<li><code>?foo=one&amp;bar=2&amp;baz=3</code></li>
</ul>
<p>However, the following query strings will be rejected:</p>
<ul>
<li><code>?foo=one&amp;bar=two</code>: <code>bar</code> must be numeric</li>
<li><code>?foo=one</code>: <code>bar</code> is missing.</li>
</ul>
<p><code>derive(Extract)</code> can also be used to deserialize request bodies:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Extract</span>)]</span>
<span class="kw">struct</span> <span class="ident">MyData</span> {
    <span class="ident">foo</span>: <span class="ident">String</span>,
    <span class="ident">bar</span>: <span class="ident">u32</span>,
    <span class="ident">baz</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
}

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">post</span>(<span class="string">&quot;/data&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">body</span>: <span class="ident">MyData</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">String</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>This is the same example as earlier, but this time the argument is named
<code>body</code>. This tells the macro to populate the argument by deserializing the
request body. The request body is deserialized into an instance of <code>MyData</code>
and passed to the resource method.</p>
<h2 id="deriveresponse" class="section-header"><a href="#deriveresponse"><code>derive(Response)</code></a></h2>
<p>Using <code>derive(Response)</code> on a struct generates a <code>Response</code> implementation,
which enables the struct to be used as a resource method return type.</p>
<p><code>derive(Response)</code> calls <a href="http://serde.rs/">Serde</a>'s <code>derive(Serialize)</code> internally, so all
the various Serde annotations apply here as well. See Serde's documentation
for more details on those.</p>
<p>Tower Web provides some additional functionality on top of Serde. The
following annotations can be used with <code>derive(Response)</code></p>
<ul>
<li><code>#[web(status)]</code></li>
<li><code>#[web(header)]</code></li>
</ul>
<p>Using these two attributes allows configuring the HTTP response status code
and header set.</p>
<p>For example:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Response</span>)]</span>
<span class="attribute">#[<span class="ident">web</span>(<span class="ident">status</span> <span class="op">=</span> <span class="string">&quot;201&quot;</span>)]</span>
<span class="attribute">#[<span class="ident">web</span>(<span class="ident">header</span>(<span class="ident">name</span> <span class="op">=</span> <span class="string">&quot;x-foo&quot;</span>, <span class="ident">value</span> <span class="op">=</span> <span class="string">&quot;bar&quot;</span>))]</span>
<span class="kw">struct</span> <span class="ident">MyData</span> {
    <span class="ident">foo</span>: <span class="ident">String</span>,
}

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">post</span>(<span class="string">&quot;/data&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">create</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="ident">MyData</span>, ()<span class="op">&gt;</span> {
            <span class="comment">// implementation</span>
        }
    }
}</pre></div>
<p>In the previous example, the HTTP response generated by <code>create</code> will have
an HTTP status code of 201 and includee the <code>X-Foo</code> HTTP header set to
&quot;bar&quot;.</p>
<p>These annotations may also be used to dynamically set the status code and
response headers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Response</span>)]</span>
<span class="kw">struct</span> <span class="ident">CustomResponse</span> {
    <span class="attribute">#[<span class="ident">web</span>(<span class="ident">status</span>)]</span>
    <span class="ident">custom_status</span>: <span class="ident">u16</span>,

    <span class="attribute">#[<span class="ident">web</span>(<span class="ident">header</span>)]</span>
    <span class="ident">x_foo</span>: <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>,
}</pre></div>
<p>When responding with <code>CustomResponse</code>, the HTTP status code will be set to
the value of the <code>custom_status</code> field and the <code>X-Foo</code> header will be set to
the value of the <code>x_foo</code> field.</p>
<p>When a handler can return unrelated response types, like a file or a web
page, <code>derive(Response)</code> can delegate the <code>Response</code> implementation to them,
through an enum:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Response</span>)]</span>
<span class="attribute">#[<span class="ident">web</span>(<span class="ident">either</span>)]</span>
<span class="kw">enum</span> <span class="ident">FileOrPage</span> {
    <span class="ident">File</span>(<span class="ident">tokio</span>::<span class="ident">fs</span>::<span class="ident">File</span>),
    <span class="ident">Page</span>(<span class="ident">String</span>),
}</pre></div>
<p>The <code>web(either)</code> attribute is only supported on enums whose variants
a single unnamed field. Right now, the other <code>web</code> attributes have no effect
when using <code>web(either)</code>.</p>
<h2 id="starting-a-server" class="section-header"><a href="#starting-a-server">Starting a server</a></h2>
<p>Once <code>Resource</code> implementations are generated, the types may be passed to
<a href="struct.ServiceBuilder.html#method.resource"><code>ServiceBuilder::resource</code></a> in order to define the web service.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">

<span class="kw">let</span> <span class="ident">addr</span> <span class="op">=</span> <span class="string">&quot;127.0.0.1:8080&quot;</span>.<span class="ident">parse</span>().<span class="ident">expect</span>(<span class="string">&quot;Invalid address&quot;</span>);
<span class="macro">println</span><span class="macro">!</span>(<span class="string">&quot;Listening on http://{}&quot;</span>, <span class="ident">addr</span>);

<span class="comment">// A service builder is used to configure our service.</span>
<span class="ident">ServiceBuilder</span>::<span class="ident">new</span>()
    <span class="comment">// We add the resources that are part of the service.</span>
    .<span class="ident">resource</span>(<span class="ident">Resource1</span>)
    .<span class="ident">resource</span>(<span class="ident">Resource2</span>)
    <span class="comment">// We run the service</span>
    .<span class="ident">run</span>(<span class="kw-2">&amp;</span><span class="ident">addr</span>)
    .<span class="ident">unwrap</span>();</pre></div>
<h2 id="testing" class="section-header"><a href="#testing">Testing</a></h2>
<p>Because web services build with Tower Web are &quot;plain old Rust types&quot;
(PORT?), testing a method is done the exact same way you would test any
other rust code.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">MyApp</span>;

<span class="macro">impl_web</span><span class="macro">!</span> {
    <span class="kw">impl</span> <span class="ident">MyApp</span> {
        <span class="attribute">#[<span class="ident">get</span>(<span class="string">&quot;/:hello&quot;</span>)]</span>
        <span class="kw">fn</span> <span class="ident">index</span>(<span class="kw-2">&amp;</span><span class="self">self</span>, <span class="ident">hello</span>: <span class="ident">String</span>) <span class="op">-&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>, ()<span class="op">&gt;</span> {
            <span class="kw">if</span> <span class="ident">hello</span> <span class="op">==</span> <span class="string">&quot;hello&quot;</span> {
                <span class="prelude-val">Ok</span>(<span class="string">&quot;correct&quot;</span>)
            } <span class="kw">else</span> {
                <span class="prelude-val">Ok</span>(<span class="string">&quot;nope&quot;</span>)
            }
        }
    }
}

<span class="attribute">#[<span class="ident">test</span>]</span>
<span class="kw">fn</span> <span class="ident">test_my_app</span>() {
    <span class="kw">let</span> <span class="ident">app</span> <span class="op">=</span> <span class="ident">MyApp</span>;

    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">app</span>.<span class="ident">index</span>(<span class="string">&quot;hello&quot;</span>.<span class="ident">to_string</span>()), <span class="prelude-val">Ok</span>(<span class="string">&quot;correct&quot;</span>));
    <span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">app</span>.<span class="ident">index</span>(<span class="string">&quot;not-hello&quot;</span>.<span class="ident">to_string</span>()), <span class="prelude-val">Ok</span>(<span class="string">&quot;nope&quot;</span>));
}</pre></div>
</div><h2 id='modules' class='section-header'><a href="#modules">Modules</a></h2>
<table><tr class='module-item'><td><a class="mod" href="config/index.html" title='tower_web::config mod'>config</a></td><td class='docblock-short'><p>Application level configuration.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="error/index.html" title='tower_web::error mod'>error</a></td><td class='docblock-short'><p>Error types and traits.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="extract/index.html" title='tower_web::extract mod'>extract</a></td><td class='docblock-short'><p>Extract data from the HTTP request.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="middleware/index.html" title='tower_web::middleware mod'>middleware</a></td><td class='docblock-short'><p>Middleware traits and implementations.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="net/index.html" title='tower_web::net mod'>net</a></td><td class='docblock-short'><p>Networking types and trait</p>
</td></tr><tr class='module-item'><td><a class="mod" href="response/index.html" title='tower_web::response mod'>response</a></td><td class='docblock-short'><p>Types and traits for responding to HTTP requests.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="routing/index.html" title='tower_web::routing mod'>routing</a></td><td class='docblock-short'><p>Map HTTP requests to Resource methods.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="service/index.html" title='tower_web::service mod'>service</a></td><td class='docblock-short'><p>Define the web service as a set of routes, resources, middlewares, serializers, ...</p>
</td></tr><tr class='module-item'><td><a class="mod" href="util/index.html" title='tower_web::util mod'>util</a></td><td class='docblock-short'><p>Utility types and traits.</p>
</td></tr><tr class='module-item'><td><a class="mod" href="view/index.html" title='tower_web::view mod'>view</a></td><td class='docblock-short'><p>Render content using templates</p>
</td></tr></table><h2 id='macros' class='section-header'><a href="#macros">Macros</a></h2>
<table><tr class='module-item'><td><a class="macro" href="macro.impl_web.html" title='tower_web::impl_web macro'>impl_web</a></td><td class='docblock-short'><p>Generate a <code>Resource</code> implementation based on the methods defined in the
macro block.</p>
</td></tr></table><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table><tr class='module-item'><td><a class="struct" href="struct.Error.html" title='tower_web::Error struct'>Error</a></td><td class='docblock-short'><p>Errors that can happen inside Tower Web.
The object of this type is serializable into &quot;Problem Detail&quot; as defined in RFC7807.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ErrorBuilder.html" title='tower_web::ErrorBuilder struct'>ErrorBuilder</a></td><td class='docblock-short'><p>Builder for Error objects.</p>
</td></tr><tr class='module-item'><td><a class="struct" href="struct.ServiceBuilder.html" title='tower_web::ServiceBuilder struct'>ServiceBuilder</a></td><td class='docblock-short'><p>Configure and build a web service.</p>
</td></tr></table></section><section id="search" class="content hidden"></section><section class="footer"></section><aside id="help" class="hidden"><div><h1 class="hidden">Help</h1><div class="shortcuts"><h2>Keyboard Shortcuts</h2><dl><dt><kbd>?</kbd></dt><dd>Show this help dialog</dd><dt><kbd>S</kbd></dt><dd>Focus the search field</dd><dt><kbd>↑</kbd></dt><dd>Move up in search results</dd><dt><kbd>↓</kbd></dt><dd>Move down in search results</dd><dt><kbd>↹</kbd></dt><dd>Switch tab</dd><dt><kbd>&#9166;</kbd></dt><dd>Go to active search result</dd><dt><kbd>+</kbd></dt><dd>Expand all sections</dd><dt><kbd>-</kbd></dt><dd>Collapse all sections</dd></dl></div><div class="infos"><h2>Search Tricks</h2><p>Prefix searches with a type followed by a colon (e.g., <code>fn:</code>) to restrict the search to a given type.</p><p>Accepted types are: <code>fn</code>, <code>mod</code>, <code>struct</code>, <code>enum</code>, <code>trait</code>, <code>type</code>, <code>macro</code>, and <code>const</code>.</p><p>Search functions by type signature (e.g., <code>vec -> usize</code> or <code>* -> vec</code>)</p><p>Search multiple things at once by splitting your query with comma (e.g., <code>str,u8</code> or <code>String,struct:Vec,test</code>)</p></div></div></aside><script>window.rootPath = "../";window.currentCrate = "tower_web";</script><script src="../aliases.js"></script><script src="../main.js"></script><script defer src="../search-index.js"></script></body></html>